/*	Max Welton 		*/
/*	Bruno Coronha Gonçalves */
/*	Cayo Cezar 		*/


#include<stdlib.h>
/****************************************************************************/
/*                                                                          */
/* 			     Module MEMORY                                  */
/* 			External Declarations 	                            */
/*                                                                          */
/****************************************************************************/


/* OSP constants */

#define MAX_PAGE       16                 /* max size of page tables        */
#define MAX_FRAME      32                 /* size of the physical memory    */
#define PAGE_SIZE      512                /* size of a page in bytes        */

#define   COST_OF_PAGE_TRANSFER      6  /* cost of reading page  from drum  */


/* external enumeration constants */

typedef enum
{
    false, true                         /* the boolean data type            */
} BOOL;

typedef enum
{
    read, write                         /* type of actions for I/O requests */
} IO_ACTION;

typedef enum
{
    load, store                         /* types of memory reference        */
} REFER_ACTION;

typedef enum
{
    running, ready, waiting, done       /* types of status                  */
} STATUS;

typedef enum
{
    iosvc, devint,                      /* types of interrupt               */
    pagefault, startsvc,
    termsvc, killsvc,
    waitsvc, sigsvc, timeint
} INT_TYPE;



/* external type definitions */

typedef struct page_entry_node PAGE_ENTRY;
typedef struct page_tbl_node PAGE_TBL;
typedef struct event_node EVENT;
typedef struct ofile_node OFILE;
typedef struct pcb_node PCB;
typedef struct iorb_node IORB;
typedef struct int_vector_node INT_VECTOR;
typedef struct frame_node FRAME;



/* external data structures */

extern struct frame_node
{
    BOOL   free;        /* = true, if free                                  */
    PCB    *pcb;        /* process to which the frame currently belongs     */
    int    page_id;     /* vitrual page id - an index to the PCB's page tbl */
    BOOL   dirty;       /* indicates if the frame has been modified         */
    int    lock_count;  /* number of locks set on page involved in an       */
    /* active I/O                                       */
    int    *hook;       /* can hook up anything here                        */
};

extern struct page_entry_node
{
    int    frame_id;    /* frame id holding this page                       */
    BOOL   valid;       /* page in main memory : valid = true; not : false  */
    int    *hook;       /* can hook up anything here                        */
};

extern struct page_tbl_node
{
    PCB         *pcb;        /* PCB of the process in question                   */
    PAGE_ENTRY   page_entry[MAX_PAGE];
    int         *hook;       /* can hook up anything here                        */
};

extern struct pcb_node
{
    int    pcb_id;         /* PCB id                                        */
    int    size;           /* process size in bytes; assigned by SIMCORE    */
    int    creation_time;  /* assigned by SIMCORE                           */
    int    last_dispatch;  /* last time the process was dispatched          */
    int    last_cpuburst;  /* length of the previous cpu burst              */
    int    accumulated_cpu;/* accumulated CPU time                          */
    PAGE_TBL *page_tbl;    /* page table associated with the PCB            */
    STATUS status;         /* status of process                             */
    EVENT  *event;         /* event upon which process may be suspended     */
    int    priority;       /* user-defined priority; used for scheduling    */
    PCB    *next;          /* next pcb in whatever queue                    */
    PCB    *prev;          /* previous pcb in whatever queue                */

    int    *hook;          /* usado para informar se o processo está no workset */
};

extern struct iorb_node
{
    int    iorb_id;     /* iorb id                                          */
    int    dev_id;      /* associated device; index into the device table   */
    IO_ACTION action;   /* read/write                                       */
    int    block_id;    /* block involved in the I/O                        */
    int    page_id;     /* buffer page in the main memory                   */
    PCB    *pcb;        /* PCB of the process that issued the request       */
    EVENT  *event;      /* event used to synchronize processes with I/O     */
    OFILE  *file;       /* associated entry in the open files table         */
    IORB   *next;       /* next iorb in the device queue                    */
    IORB   *prev;       /* previous iorb in the device queue                */
    int    *hook;       /* can hook up anything here                        */
};

extern struct int_vector_node
{
    INT_TYPE cause;           /* cause of interrupt                         */
    PCB    *pcb;              /* PCB to be started (if startsvc) or pcb that*/
    /* caused page fault (if fagefault interrupt) */
    int    page_id;           /* page causing pagefault                     */
    int    dev_id;            /* device causing devint                      */
    EVENT  *event;            /* event involved in waitsvc and sigsvc calls */
    IORB   *iorb;             /* IORB involved in iosvc call                */
};



/* extern variables */

extern INT_VECTOR Int_Vector;           /* interrupt vector         	     */
extern PAGE_TBL *PTBR;                  /* page table base register 	     */
extern FRAME Frame_Tbl[MAX_FRAME];      /* frame table              	     */
extern int Prepage_Degree;		/* global degree of prepaging (0-10) */



/* external routines */

extern siodrum(/* action, pcb, page_id, frame_id */);
/*  IO_ACTION   action;
    PCB         *pcb;
    int         page_id, frame_id;  */
extern int get_clock();
extern gen_int_handler();



/****************************************************************************/
/*                                                                          */
/*                                                                          */
/*                              Module MEMORY                               */
/*                            Internal Routines                             */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

/* Estrutura para armazenar os frames */
typedef struct No
{
    struct No *next;
    struct No *prev;
    int id_frame;
} No;

/* Fila de Frames */
typedef struct fila
{
    No *inicio;
    No *fim;
} Fila;

Fila frameQueue;  //fila de molduras
int freeFrame;  //quantidade de molduras livres

void iniciarFila() // Inicializa a fila de frames
{

    frameQueue.inicio = (No*)malloc(sizeof(No));
    if(frameQueue.inicio == NULL)
        exit(EXIT_FAILURE);

    frameQueue.fim = (No*)malloc(sizeof(No));
    if(frameQueue.fim == NULL)
        exit(EXIT_FAILURE);

    frameQueue.inicio->prev = frameQueue.fim->next = NULL;
    frameQueue.inicio->next = frameQueue.fim;
    frameQueue.fim->prev = frameQueue.inicio;
}

/*  Verifica se a fila de frames está vazia */
int isEmpty(Fila frameQueue)
{
    return frameQueue.inicio->next == frameQueue.fim;
}

/* Insere novo frame na fila de frames */
void insertFrame(int id)
{

    No *aux = (No *)malloc(sizeof(No));
    if(aux == NULL)
        exit(EXIT_FAILURE);

    aux->id_frame = id;
    aux->next = frameQueue.fim;
    aux->prev = frameQueue.fim->prev;
    frameQueue.fim->prev->next = aux;
    frameQueue.fim->prev = aux;
}

int removeFrame()
{
    No *aux;
    int id;

    if (isEmpty(frameQueue))
        return -1;

    aux = frameQueue.inicio->next;
    aux->next->prev = frameQueue.inicio;
    frameQueue.inicio->next = aux->next;
    id = aux->id_frame;
    free(aux);
    return id;
}

/* Falta de pagina */
void pageFault(PCB *pcb, int page_id)
{
    Int_Vector.cause = pagefault;  // causa da interrupão  (pagefault é um enum  INT_TYPE)
    Int_Vector.page_id = page_id; // id da pagina que não foi referenciada na memória física
    Int_Vector.pcb = pcb;
    gen_int_handler();  //suspende o processo atual e transfere o controle para o módulo PAGEINT. USADO PARA SIMULAR FALTA DE PAGINA

}

void memory_init()
{
    int i=0;
    iniciarFila();
    freeFrame = MAX_FRAME;

    //colaca bit r igual a 0 (nao referenciada) para toda posição da tabela de molduras
    while(i < MAX_FRAME)
    {
        Frame_Tbl[i].hook = (int*)malloc(sizeof(int));
        *Frame_Tbl[i].hook = 0;
        i++;
    }
}

int start_cost(pcb)
PCB *pcb;
{

}

void prepage(pcb)
PCB *pcb;
{

}

int secondChance()
{
    int pagina;
    int indice = 0;

    if (freeFrame > 0)
    {
        while ((Frame_Tbl[indice].free == false  || Frame_Tbl[indice].lock_count > 0) && indice < MAX_FRAME)
            indice++;

        /* Verdadeiro caso tenha encontrado uma posicao livre na memoria */
        if (indice < MAX_FRAME)
        {
            insertFrame(indice);
            *Frame_Tbl[indice].hook = 1;
            freeFrame--;
            return indice;
        }
    }

    //Caso indice > MAX_FRAME, não há posição livre na memória, é preciso trocar paginas.

    /* começa o algoritmo de segunda chance para substituir uma página

    	remove uma página que está no início de fila_frame insere ela no final
    	até que seja removido uma página que tenha bit de refenciamento hook=0  ?
    	ou se a variável lock_count>0;
    */
    pagina = removeFrame();

    /* Enquanto hook==1 ou lock_count>0 */
    while (*Frame_Tbl[pagina].hook != 0 || Frame_Tbl[pagina].lock_count > 0)
    {
        *Frame_Tbl[pagina].hook = 0; //se o bit r for 1, eu dou uma segunda chance para ela, seto o bit r pra zero e a insiro no final da fila.
        insertFrame(pagina);
        pagina = removeFrame(); //devolve o id da pagina
    }

    *Frame_Tbl[pagina].hook = 1; //marca a página como refenciada(carregada)
    insertFrame(pagina); //insere ela no final de frameQueue
    return pagina;
}

/* Função responsável por fazer alocação e substituição de página */
void get_page(pcb,page_id)
PCB *pcb;
int page_id;
{
    int id;
    int idPage;

    id = secondChance();

    //página que estava sendo utilizada no processo anterior
    idPage = Frame_Tbl[id].page_id;

    //verifica se o frame foi utilizado
    if(!Frame_Tbl[id].free)
    {
        //modifica a referencia

        Frame_Tbl[id].pcb->page_tbl->page_entry[idPage].valid = false; //a moldura antes referenciada na memoria principal é setada como não referenciada.

        //verifica se o frame foi modificado
        if(Frame_Tbl[id].dirty)
            siodrum(write, Frame_Tbl[id].pcb, Frame_Tbl[id].page_id, id); // se o frame foi modificado é preciso grava-lo em disco
    }

    //Carrega a nova pagina

    //le do disco
    siodrum(read, pcb, page_id, id);

    //marca como utilizado
    Frame_Tbl[id].free = false;

    //marca como não modificado
    Frame_Tbl[id].dirty = false;

    //Pcb da página
    Frame_Tbl[id].pcb = pcb;

    //armazena o endereço fisico na paginas
    Frame_Tbl[id].page_id = page_id;

    Frame_Tbl[id].lock_count = 0;

    //armazena o endereço fisico na pagina
    pcb->page_tbl->page_entry[page_id].frame_id = id;

    //marca a pagina como carregada na memoria fisica
    pcb->page_tbl->page_entry[page_id].valid = true;

    *Frame_Tbl[id].hook = 1;

}

/* responsável por bloquear uma página que esteja usando Dispositivo I/O */
void lock_page(iorb)
IORB *iorb;
{
    int page_id = iorb->page_id; // pega o id da página bloqueada
    PCB *pcb = iorb->pcb; // aponta para o processo que terá uma página bloqueada
    PAGE_ENTRY *page = &(pcb->page_tbl->page_entry[page_id]); // acessa a página que está sendo bloqueada

    if(page->valid == false)   //se a pagina não está na memória principal ocorre uma falta de página.
        pageFault(pcb, page_id);

    if(iorb->action == read)  //se a ação do iorb for "ler", marco a página como modificada
        Frame_Tbl[page->frame_id].dirty = true;

    Frame_Tbl[page->frame_id].lock_count++;
}


/* responsável por desbloquear uma página quando termina de usar Dispositivo I/O */
void unlock_page(iorb)
IORB  *iorb;
{
    int page_id = iorb->page_id; //id da pagina
    PCB *pcb = iorb->pcb; //processo que solicitou a operacao de i/o
    PAGE_ENTRY page = pcb->page_tbl->page_entry[page_id];
    Frame_Tbl[page.frame_id].lock_count--;  //decrementa a quantidade de bloqueios da pagina
}

void deallocate(pcb)
PCB *pcb;
{
    int totalFrames, i = 0, frame;

    if (isEmpty(frameQueue))
        return;

    totalFrames = MAX_FRAME - freeFrame;   //Quantos frames  não estão livres?

    for(i=0; i<totalFrames; i++)
    {
        frame = removeFrame();

        if (Frame_Tbl[frame].free == false && Frame_Tbl[frame].pcb->pcb_id == pcb->pcb_id)  //posição do frame nao livre e se o processo que está na tabela de pagina é o mesmo recebido como parametro
        {
            Frame_Tbl[frame].free = true;
            Frame_Tbl[frame].dirty = false;
            Frame_Tbl[frame].pcb = 0;
            freeFrame++;
            *Frame_Tbl[frame].hook = 0;
        }
        else
            insertFrame(frame);

    }
}

//simula referencia à memoria pelo CPU
void refer(logic_addr,action)
int logic_addr;
REFER_ACTION action;
{
    int page_id = logic_addr/PAGE_SIZE;	//indice da tabela de paginas

    //processo dono da pagina referenciada
    PCB *pcb = PTBR->pcb;

    //pega a página referenciada no processo pcb
    PAGE_ENTRY *page = &(pcb->page_tbl->page_entry[page_id]);

    //se a página não não está na memoria principal, ocorre falta de pagina
    if(!page->valid)
        pageFault(pcb, page_id);

    //atualiza o campo de ultima referencia
    *Frame_Tbl[page->frame_id].hook = 1;

    if(action == store)  // action = armazenar?
    {
        //muda dirty no frame correspondente, informando que a mesma foi modificada
        Frame_Tbl[page->frame_id].dirty = true;
    }
}

/* end of module */